1) Contains Duplicate number in array
	Code :
	class Solution {
    public boolean containsDuplicate(int[] nums) {
        HashSet<Integer> set = new HashSet<>();
        for(int i : nums){
            if(set.contains(i)) return true;
            set.add(i);
        }
        return false;
    }
}

2) Missing Number : Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.
	Input: nums = [3,0,1]
	Output: 2
	Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.
	
	Code :
	class Solution {
    public int missingNumber(int[] nums) {
        int x1 = nums[0]; //to calculate xor of all array numbers
        int x2 = 1; //to caluculate xor of 1 to n

        for(int i=1;i<nums.length;i++){
            x1 ^= nums[i];
        }

        for(int i=2;i<=nums.length;i++){
            x2 ^= i;
        }

        return x1^x2;
    }
}

3) Find All Numbers Disappeared in an Array : Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n]
	+that do not appear in nums.
	Input: nums = [4,3,2,7,8,2,3,1]
	Output: [5,6]
	
	Code :
	class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        List<Integer> l = new ArrayList<>();
        int n = nums.length;
        for(int i=0;i<n;i++){
            int index = Math.abs(nums[i]) - 1;
            if(nums[index] > 0) nums[index] *= -1;
        }
        for(int i=0;i<n;i++){
            if(nums[i] > 0) l.add(i+1);
        }
        return l;
    }
}

4) Single Number : Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.

	You must implement a solution with a linear runtime complexity and use only constant extra space.
	Input: nums = [2,2,1]
	Output: 1
	
	Code :
	class Solution {
    public int singleNumber(int[] nums) {
        int result = nums[0];
        for(int i=1;i<nums.length;i++){
            result ^= nums[i];
        }
        return result;
    }
}

5) Linked List Cycle : (Topic Tags : Fast and slow pointer)
	Example 1:
	
	<img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png">
	
	Input: head = [3,2,0,-4], pos = 1
	Output: true
	Explanation: There is a cycle in the linked list, where the tail 
	
	Code :
	public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head==null || head.next == null){
            return false;
        }
        ListNode slow = head,fast=head.next;
        while(fast != null && fast.next != null){
            if(slow == fast) return true;
            fast = fast.next.next;
            slow = slow.next;
        }
        return false;
    }
}
	
6) Middle of the Linked List : (Topic Tags : Fast and slow pointer)
	Given the head of a singly linked list, return the middle node of the linked list.

	If there are two middle nodes, return the second middle node.

	Example 1:
	<img src = "https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg">

	Input: head = [1,2,3,4,5]
	Output: [3,4,5]
	Explanation: The middle node of the list is node 3.
	
	Code :
	class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode front = head.next;
        ListNode back = head;
        while(front!=null && front.next!=null){
            front = front.next.next;
            back = back.next;
        }
        if(front == null) return back;
        return back.next;
    }
}

7) Reverse Linked List (Topic : Inplace reversal of linked list)
	Given the head of a singly linked list, reverse the list, and return the reversed list.

 

	Example 1:


	Input: head = [1,2,3,4,5]
	Output: [5,4,3,2,1
	
	Code :
	class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode curr = head;
        ListNode prev = null;
        ListNode temp = head;
        while(curr != null){
            temp = temp.next;
            curr.next = prev;
            prev = curr;
            curr = temp;
        }
        return prev;
    }
}

8) Palindrome Linked List : (Topic Tags : Fast and slow pointer)
	Given the head of a singly linked list, return true if it is a 
	palindrome
	 or false otherwise.

	 

	Example 1:


	Input: head = [1,2,2,1]
	Output: true
	
	Code :
	class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null || head.next == null){
            return true;
        }
        if(head.next.next == null){
            return head.val == head.next.val;
        }
        long rev_num = 0;
        
        while(head != null){
            rev_num = (rev_num*10) + head.val;
            head = head.next;
        }
        
        long num = 0;
        long x = rev_num;
        while(x != 0){
            num = (num*10) + (x%10);
            x /= 10;
        }
        return num == rev_num;
	}
}
	
9)  Remove Linked List Elements : (Topic Tags : Fast and slow pointer)
	Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.
	Example 1:


	Input: head = [1,2,6,3,4,5,6], val = 6
	Output: [1,2,3,4,5]
	
	Code :
	class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode curr = dummy;
        while(curr.next != null){
            if(curr.next.val == val){
                curr.next = curr.next.next;
            }else
            curr = curr.next;
        }
        
        return dummy.next;
    }
}

10) Remove Duplicates from Sorted List	(Topic Tags : Fast and slow pointer)
	Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.

	Example 1:


	Input: head = [1,1,2]
	Output: [1,2]
	
	Code : 
	class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head==null || head.next==null){
            return head;
        }
        ListNode temp = head.next;
        ListNode ptr = head;
        while(temp!=null){
            if(temp.val != ptr.val){
                ptr.next = temp;
                ptr = ptr.next;
            }
            temp = temp.next;
        }
        ptr.next = null;
        return head;
    }
}

11) Merge Two Sorted Lists (Topic Tags : Two pointer)
	You are given the heads of two sorted linked lists list1 and list2.

	Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.

	Return the head of the merged linked list.

	 

	Example 1:


	Input: list1 = [1,2,4], list2 = [1,3,4]
	Output: [1,1,2,3,4,4]
	
	Code :
	class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode newhead = null;
    ListNode ptr1 = list1; 
    ListNode ptr2 = list2; 
    ListNode ptr3 = null;

    while (ptr1 != null && ptr2 != null) {
        if (ptr1.val <= ptr2.val) {
            if (newhead == null) {
                newhead = ptr1;
                ptr3 = newhead;
            } else {
                ptr3.next = ptr1;
                ptr3 = ptr3.next;
            }
            ptr1 = ptr1.next;
        } else {
            if (newhead == null) {
                newhead = ptr2;
                ptr3 = newhead;
            } else {
                ptr3.next = ptr2;
                ptr3 = ptr3.next;
            }
            ptr2 = ptr2.next;
        }
    }
    
    if (ptr1 != null) 
        ptr3.next = ptr1;
    if (ptr2 != null)
        ptr3.next = ptr2;

    return newhead;
    }
}

12) Binary Search (Topic : Binary Search)
	Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.

	You must write an algorithm with O(log n) runtime complexity.

	 

	Example 1:

	Input: nums = [-1,0,3,5,9,12], target = 9
	Output: 4
	Explanation: 9 exists in nums and its index is 4
	
	Code :
	class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length-1;
        while(left <= right){
            int mid = (left + right)/2;
            if(nums[mid] == target) return mid;
            if(nums[mid] < target) left = mid+1;
            else right = mid-1;
        }
        return -1;
    }
}

13) Find Smallest Letter Greater Than Target (Topic : Binary Search)
	You are given an array of characters letters that is sorted in non-decreasing order, and a character target. There are at least two different characters in letters.
	Return the smallest character in letters that is lexicographically greater than target. If such a character does not exist, return the first character in letters.
	Example 1:

	Input: letters = ["c","f","j"], target = "a"
	Output: "c"
	Explanation: The smallest character that is lexicographically greater than 'a' in letters is 'c'.
	
	Code :
	class Solution {
    public char nextGreatestLetter(char[] arr, char target) {
        int left = 0, right = arr.length-1;
        if(arr[0] > target || arr[right] <= target) return arr[0];
        char res = ' ';
        while(left <= right){
            int mid = (left+right)/2;
            if(arr[mid] > target){
                res = arr[mid];
                right = mid-1;
            }
            if(arr[mid] <= target){
                left = mid+1;
            }else{
                right = mid-1;
            }
        }
        return res;
    }
}

14) Convert 1D Array Into 2D Array (Topic : Array)
	Input: original = [1,2,3,4], m = 2, n = 2
	Output: [[1,2],[3,4]]
	Explanation: The constructed 2D array should contain 2 rows and 2 columns.
	The first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array.
	The second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array.
	
	Code :
	class Solution {
    public int[][] construct2DArray(int[] original, int m, int n) {
        int result[][] = new int[m][n];
        if(m*n != original.length) return new int[0][0];
     
        int k=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                result[i][j] = original[k];
                k++;
            }
        }
        return result;
    }
}

15)  Move Zeroes (Topic : Arrays, Two Pointers)
	Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

	Note that you must do this in-place without making a copy of the array.

	 

	Example 1:

	Input: nums = [0,1,0,3,12]
	Output: [1,3,12,0,0]
	
	Code :
	class Solution {
    public void swap(int arr[],int i, int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    public void moveZeroes(int[] nums) {
        int i=0,j=0;
        while(i<nums.length){
            if(nums[i] != 0){
                swap(nums,i,j);
                j++;
            }
            i++;
        }
    }
}

16) Product of Array Except Self   (Topic : Arrays)
	Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].

	The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.

	You must write an algorithm that runs in O(n) time and without using the division operation.

	 

	Example 1:

	Input: nums = [1,2,3,4]
	Output: [24,12,8,6]
	
	Code :
	class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int pre = 1;
        int post = 1;
        int answer[] = new int[n];

        for(int i=0;i<n;i++){
            answer[i] = pre;
            pre *= nums[i];
        }

        for(int i=n-1;i>=0;i--){
            answer[i] *= post;
            post *= nums[i];
        }

        return answer;
    }
}

17) Find the Duplicate Number (Topic : Array, Binary Search, Two Pointers)
	Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.

	There is only one repeated number in nums, return this repeated number.

	You must solve the problem without modifying the array nums and uses only constant extra space.

	 

	Example 1:

	Input: nums = [1,3,4,2,2]
	Output: 2
	
	Code :
	class Solution {
    public int findDuplicate(int[] nums) {
        int slow = 0, fast = 0;
        do{
            slow = nums[slow];
            fast = nums[nums[fast]];
        }while(slow != fast);

        slow = 0;
        while(slow != fast){
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }    
}

18) Find All Duplicates in an Array (Topic : Arrays)

	Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.

	You must write an algorithm that runs in O(n) time and uses only constant extra space.

	Example 1:

	Input: nums = [4,3,2,7,8,2,3,1]
	Output: [2,3]
	
	Code :
	class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> l = new ArrayList<>();
        
        for(int i=0;i<nums.length;i++){
            int idx = Math.abs(nums[i]) - 1;
            if(nums[idx] < 0) l.add(Math.abs(nums[i]));
            else nums[idx] *= -1;
        }

        return l;
    }
}

19) Set Matrix Zeroes   (Topic : Arrays)
	Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.
	You must do it in place.
	Example 1:

	Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]
	Output: [[1,0,1],[0,0,0],[1,0,1]]
	
	Code :
	class Solution {
    public void setZeroes(int[][] matrix) {
        boolean found_row = false, found_col = false;
        for(int i=0;i<matrix.length;i++){
           
            for(int j=0;j<matrix[i].length;j++){
                if(matrix[i][j] == 0){
                    if(i == 0) found_row = true;
                    if(j == 0) found_col = true;
                    matrix[0][j] = 0;
                    matrix[i][0] = 0;
                }
            }
        }
        
        for(int i=1;i<matrix.length;i++){
            for(int j=1;j<matrix[i].length;j++){
                if(matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;
            }
        }

        if(found_col)
        for(int i=0;i<matrix.length;i++){
            matrix[i][0] = 0;
        }

        if(found_row)
        for(int i=0;i<matrix[0].length;i++){
            matrix[0][i] = 0;
        }
	}
}

20) Spiral Matrix	(Topic : Arrays)
	Given an m x n matrix, return all elements of the matrix in spiral order.
	Example 1:
	Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
	Output: [1,2,3,6,9,8,7,4,5]
	
	Code :
	class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> l = new ArrayList<>();
        int m = matrix.length, n = matrix[0].length;
        int rowBegin = 0, rowEnd = m-1, colBegin = 0, colEnd = n-1;

        while(rowBegin <= rowEnd && colBegin <= colEnd) {
            for(int i=colBegin;i<=colEnd;i++) l.add(matrix[rowBegin][i]);
            rowBegin++;

            for(int i=rowBegin;i<=rowEnd;i++) l.add(matrix[i][colEnd]);
            colEnd--;

            if(rowBegin <= rowEnd)
            for(int i=colEnd;i>=colBegin;i--) l.add(matrix[rowEnd][i]);
            rowEnd--;

            if(colBegin <= colEnd)
            for(int i=rowEnd;i>=rowBegin;i--) l.add(matrix[i][colBegin]);
            colBegin++;
        }
        return l;
    }
}

21)  Peak Index in a Mountain Array (Topic : Binary Search)
	An array arr is a mountain if the following properties hold:

	arr.length >= 3
	There exists some i with 0 < i < arr.length - 1 such that:
	arr[0] < arr[1] < ... < arr[i - 1] < arr[i] 
	arr[i] > arr[i + 1] > ... > arr[arr.length - 1]
	Given a mountain array arr, return the index i such that arr[0] < arr[1] < ... < arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1].

	You must solve it in O(log(arr.length)) time complexity.

	 

	Example 1:

	Input: arr = [0,1,0]
	Output: 1
	
	Code :
	class Solution {
    public int peakIndexInMountainArray(int[] arr) {
        if(arr.length < 3) return 0;
       int left = 1, right = arr.length-2;
       while(left <= right){
           int mid = (left + right)/2;
           if(arr[mid] > arr[mid-1] && arr[mid] > arr[mid+1]) return mid;
           else if(arr[mid] > arr[mid-1]) left = mid+1;
           else right = mid-1;
           else low = mid+1; //if there is depth
       }
       return 0;
    }
}

22) Minimum in Sorted Rotated Array  (Topic Tags : Binary Search)

	Input: nums = [3,4,5,1,2]
	Output: 1
	Explanation: The original array was [1,2,3,4,5] rotated 3 times.
	
	Code :
	class Solution {
    public int findMin(int[] arr) {
        int low = 0, high = arr.length-1;
        int ans = Integer.MAX_VALUE;
        //find min of each sorted part in array
        while( low <= high ){
            int mid = (low + high)/2;

            if(arr[low] <= arr[high]){      //If array is already sorted
                return Math.min(arr[low],ans);
            }
            if(arr[mid] >= arr[low]){     //If left of mid is sorted
                ans = Math.min(ans,arr[low]);
                low = mid+1;
            }else{
                ans = Math.min(ans,arr[mid]);        //If right of mid is sorted
                high = mid-1;
            }
        }
        return ans;
    }
}

23) Find Peak Element   (Topic : Binary Search)
	A peak element is an element that is strictly greater than its neighbors.

	Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.

	You may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.

	You must write an algorithm that runs in O(log n) time.

	Example 1:

	Input: nums = [1,2,3,1]
	Output: 2
	Explanation: 3 is a peak element and your function should return the index number 2.
	
	Code :
	
	class Solution {
    public int findPeakElement(int[] nums) {
        if(nums.length == 1) return 0;
        if(nums[0] > nums[1]){
            return 0;
        }
        if(nums[nums.length-1] > nums[nums.length-2]) return nums.length-1;
        int low = 1, high = nums.length-2;
        while(low <= high){
            int mid = (low+high)/2;
            if(nums[mid] > nums[mid-1] && nums[mid] > nums[mid+1]) return mid;   //If mid is at peak
            else if(nums[mid] > nums[mid-1]) low = mid+1;   //peak is at right of mid as it is increasing
            else high = mid-1;   //peak is at left of mid as it is decreasing
        }
        return -1;
    }
}

24) Search in Rotated Sorted Array   (Topic Tags : Binary Search)
	There is an integer array nums sorted in ascending order (with distinct values).

	Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].

	Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.

	You must write an algorithm with O(log n) runtime complexity.

	 

	Example 1:

	Input: nums = [4,5,6,7,0,1,2], target = 0
	Output: 4
	
	Code :
	class Solution {
    public int search(int[] arr, int target) {
        int low=0, high=arr.length-1;
        while(low <= high){
            int mid = (low+high)/2;
            if(arr[mid] == target) return mid;
            if(arr[low] <= arr[mid]){   //if left part is sorted
                if(target <= arr[mid] && target >= arr[low]){ 
                    high = mid-1;
                }else{
                    low = mid+1;
                }
            }else{
                if(target >= arr[mid] && target <= arr[high]){  //if right part is sorted
                    low = mid+1; 
                }else{
                    high = mid-1;
                }
            }
        }
        return -1;
    }
}

25) Search in Rotated Sorted Array II
	Example 1:

	Input: nums = [2,5,6,0,0,1,2], target = 0
	Output: true
	
	Code :
	class Solution {
    public boolean search(int[] nums, int target) {
        int low = 0, high = nums.length-1;
        while(low <= high){
            int mid = (low + high)/2;
            if(nums[mid] == target) return true;
            if(nums[mid] == nums[low] && nums[mid]==nums[high]){   //Here is ambuguity to find which part is sorted 
                low++;
                high--;
                continue;
            }
            if(nums[mid] >= nums[low]){
                if(target >= nums[low] && target <= nums[mid]){
                    high = mid-1;
                }else{
                    low = mid+1;
                }
            }else{
                if(target >= nums[mid] && target <= nums[high]){
                    low = mid+1;
                }else{
                    high = mid-1;
                }
            }
        }
        return false;
    }
}

26) Search a fully sorted 2D Matrix
	You are given an m x n integer matrix matrix with the following two properties:

	Each row is sorted in non-decreasing order.
	The first integer of each row is greater than the last integer of the previous row.
	Given an integer target, return true if target is in matrix or false otherwise.

	You must write a solution in O(log(m * n)) time complexity.

	 

	Example 1:


	Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
	Output: true
	
	Code :
	class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        //Solving by visualizing a 2D matrix in a single array 
        //index in single array = matrix[index/m][index%m] i.e. row = index/m, col = index%m
        int m = matrix.length, n = matrix[0].length;
        int low = 0, high = m*n-1;
        while(low <= high){
            int mid = (low+high)/2;
            int row = mid/n, col = mid%n;
            if(matrix[row][col] == target) return true;
            if(matrix[row][col] > target) high = mid-1;
            else low = mid+1;
        }
        return false;
    }
}

27) Search a 2D Matrix II
	Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:

	Integers in each row are sorted in ascending from left to right.
	Integers in each column are sorted in ascending from top to bottom.
	 

	Example 1:


	Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
	Output: true
	
	Code :
	class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
	//Eliminating rows and columns, not directly binary search
	//starting top right corner or bottom left corner of matrix as these two points only have one side increasing and other decreasing. 
	//Using this we can decide whether we have to eleminate row or column
	//Time => O(log(m*n))
        int row = 0, col = matrix[0].length-1;
        while(row < matrix.length && col >= 0){
            if(matrix[row][col] == target) return true;
            if(matrix[row][col] > target) col--;
            else row++;
        }
        return false;
    }
}

28) Linked List Cycle II (Topic Tags : Fast and Slow Pointers)
	Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.

	There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.

	Do not modify the linked list.

	Example 1:

	Input: head = [3,2,0,-4], pos = 1
	Output: tail connects to node index 1
	Explanation: There is a cycle in the linked list, where tail connects to the second node.
	
	Code :
	public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head == null) return null;
        ListNode fast = head, slow = head;
        while(fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
            if(slow == fast) break;
        }
        if(fast == null || fast.next == null) return null;
        slow = head;
        while(slow != fast){
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}

29) Add Two Numbers    (Topic Tags : Fast and Slow Pointers)
	You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

	You may assume the two numbers do not contain any leading zero, except the number 0 itself.

	Example 1:

	Input: l1 = [2,4,3], l2 = [5,6,4]
	Output: [7,0,8]
	Explanation: 342 + 465 = 807.
	
	Code :
	class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode ans = null;
        ListNode head = null;
        int carry = 0;
        while(l1 != null && l2 != null){
            int curr_sum = l1.val + l2.val + carry;
            if(curr_sum < 10){
               if(ans == null) {
                   ans = new ListNode(curr_sum);
                   head = ans;
                }
               else{
                   ans.next = new ListNode(curr_sum);
                   ans = ans.next;
               }
               carry = 0;
            }else{
                if(ans == null) {
                    ans = new ListNode(curr_sum%10);
                    head = ans;
                }
                else {
                    ans.next = new ListNode(curr_sum%10);
                    ans = ans.next;
                }
                carry = 1;
            }
            l1 = l1.next;
            l2 = l2.next;
        }
        while(l1 != null){
            ans.next = new ListNode((l1.val + carry)%10);
            carry = (l1.val + carry)/10;
            ans = ans.next;
            l1 = l1.next;
        }
        while(l2 != null){
            ans.next = new ListNode((l2.val + carry)%10);
            carry = (l2.val + carry)/10;
            ans = ans.next;
            l2 = l2.next;
        }
        if(carry == 1) ans.next = new ListNode(1);
        return head;
    }
}

30) Remove Nth Node From End of List	(Topic Tags : Fast and Slow Pointers)
	Given the head of a linked list, remove the nth node from the end of the list and return its head.

	Example 1:

	Input: head = [1,2,3,4,5], n = 2
	Output: [1,2,3,5]
	
	Code :
	class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode fast = head;
        ListNode slow = head;
 
        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }
 
        if (fast == null) {
            head = head.next;
            return head;
        }
 
        while (fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }
        slow.next = slow.next.next;
        return head;
    }
}

31) Reverse Linked List II   (Topic Tags : In-place reversal of a linked list)
	Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.

	Example 1:

	Input: head = [1,2,3,4,5], left = 2, right = 4
	Output: [1,4,3,2,5]
	
	Code :
	class Solution {
    public void reverse(ListNode start,ListNode end,ListNode prev_start, ListNode after_end){
        ListNode prev = after_end;
        ListNode curr = start;
        ListNode temp = curr;
        
        while(curr != after_end){
            temp = temp.next;
            curr.next = prev;
            prev = curr;
            curr = temp;
        }
    }
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if(head == null || head.next == null || left == right) return head;
        ListNode start = head, end = head;
        ListNode prev_start = head, after_end = head;

        for(int i=1;(i<left || i<right);i++){
            if(i < left) {
                prev_start = start;
                start = start.next;
            }
            end = end.next;
        }
        after_end = end.next;

        reverse(start,end,prev_start,after_end);

        if(left == 1) return end;

        if(prev_start.next != null)
            prev_start.next = end;

        return head;
    }
}

32) Rotate List 	(Topic Tags : In-place reversal of a linked list)
	Given the head of a linked list, rotate the list to the right by k places.

	Example 1:

	Input: head = [1,2,3,4,5], k = 2
	Output: [4,5,1,2,3]
	
	Code :
	class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if(head == null || k == 0) return head;

        ListNode fast = head, slow = head, pre_slow = head;

        int length = 1;
        
        while(fast.next != null){
            pre_slow = slow;
            slow = slow.next;
            fast = fast.next;
            length++;
        }

        k = k%length;

        if(k == 0) return head;

        fast = head;
        slow = head;
        for(int i=1;i<k;i++) fast = fast.next;

        while(fast.next != null){
            pre_slow = slow;
            slow = slow.next;
            fast = fast.next;
        }

        fast.next = head;
        pre_slow.next = null;
        return slow;
    }
}

33)  Swap Nodes in Pairs	(Topic Tags : In-place reversal of a linked list)
	Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)

	Example 1:

	Input: head = [1,2,3,4]
	Output: [2,1,4,3]
	
	Code :
	class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null) return head;

        ListNode front = head.next, back = head;
        ListNode newhead = head.next;

        while(front != null){
            ListNode temp = front.next;
            front.next = back;
            if(temp == null) {
                back.next = null;
                break;
            }
            else if(temp.next == null) {
                back.next = temp;
                break;
            }
            else back.next = temp.next;
            back = temp;
            front = temp.next;
        }
        return newhead;
    }
}

34) Odd Even Linked List 	(Topic Tags : In-place reversal of a linked list)
	Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.

	The first node is considered odd, and the second node is even, and so on.

	Note that the relative order inside both the even and odd groups should remain as it was in the input.

	You must solve the problem in O(1) extra space complexity and O(n) time complexity.

	Example 1:

	Input: head = [1,2,3,4,5]
	Output: [1,3,5,2,4]
	
	Code :
	class Solution {
    public ListNode oddEvenList(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode odd = head, even = head.next, op = head, ep = head.next;
        while(ep != null && ep.next != null){
            op.next = ep.next;
            op = op.next;
            ep.next = op.next;
            ep = ep.next;
        }
        op.next = even;
        return head;
    }
}

35) Maximum Average Subarray I		(Topic Tags : Sliding Window)
	You are given an integer array nums consisting of n elements, and an integer k.

	Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted.

	Example 1:

	Input: nums = [1,12,-5,-6,50,3], k = 4
	Output: 12.75000
	Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75
	
	Code :
	class Solution {
    public double findMaxAverage(int[] nums, int k) {
        double sum = 0;
        for(int i=0;i<k;i++) sum += nums[i];
        double avg = sum/k;
        int i=0,j=k;
        while(j < nums.length){
            sum += nums[j];
            sum -= nums[i];
            avg = Math.max(avg,sum/k);
            j++;i++;
        }
        return avg;
    }
}

36)	Minimum Size Subarray Sum   (Topic Tags : Sliding Window)
	Given an array of positive integers nums and a positive integer target, return the minimal length of a 
	subarray
	whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.

	Example 1:

	Input: target = 7, nums = [2,3,1,2,4,3]
	Output: 2
	Explanation: The subarray [4,3] has the minimal length under the problem constraint.
	
	Code :
	class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int i=0, j=0, len=Integer.MAX_VALUE;
        if(nums[0] >= target) return 1;
        int sum = 0;
        while(i < nums.length){
            sum += nums[i];
            
            while(j <= i && sum >= target){
                len = Math.min(len,i-j+1);
                sum -= nums[j];
                j++;
            }

            i++;
        }
        if(len == Integer.MAX_VALUE) return 0;
        return len;
    }
}

37) Permutation in String	(Topic Tags : Sliding Window)

	Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.

	In other words, return true if one of s1's permutations is the substring of s2.

	Example 1:

	Input: s1 = "ab", s2 = "eidbaooo"
	Output: true
	Explanation: s2 contains one permutation of s1 ("ba").
	
	Code :
	class Solution {
    public boolean checkInclusion(String s1, String s2) {
    
         int[] map = new int[26];
        for(char c : s1.toCharArray()) map[c - 'a']++;
        int j = 0, i = 0;
        int count_chars = s1.length();
        while(j < s2.length()){
            if(map[s2.charAt(j++) - 'a']-- > 0)
                count_chars--;
            if(count_chars == 0) return true;
            if(j - i == s1.length() && map[s2.charAt(i++) - 'a']++ >= 0)
                count_chars++;
        }
        return false;
    }
}

38) Longest Substring Without Repeating Characters	(Topic Tags : Sliding Window)
	Given a string s, find the length of the longest 
	substring without repeating characters.

	Example 1:

	Input: s = "abcabcbb"
	Output: 3
	Explanation: The answer is "abc", with the length of 3.
	
	Code :
	class Solution {
    public int lengthOfLongestSubstring(String s) {
        
        int i=0,j=0,res=Integer.MIN_VALUE;
        HashSet<Character> set = new HashSet<>();
        while(i < s.length()){
            if(set.contains(s.charAt(i))){
                res = Math.max(res,i-j);
                set.remove(s.charAt(j));
                j++;
            }else{
            set.add(s.charAt(i));
            i++;
            }
        }
        return Math.max(res,i-j);
    }
}

39) Maximum number of vowels in a substring of given length		(Topic Tags : Sliding Window)
	Given a string s and an integer k, return the maximum number of vowel letters in any substring of s with length k.

	Vowel letters in English are 'a', 'e', 'i', 'o', and 'u'.

	Example 1:

	Input: s = "abciiidef", k = 3
	Output: 3
	Explanation: The substring "iii" contains 3 vowel letters.
	
	Code :
	class Solution {
    public int maxVowels(String s, int k) {
        int end_window=0;
        int res = 0;
        while(end_window < k){
            char ch = s.charAt(end_window);
            if(ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u'){
                res++;
            }
            end_window++;
        }
        int start_window = 0, len = res;;
        while(end_window < s.length()){
            char ch1 = s.charAt(end_window);
            char ch0 = s.charAt(start_window);
            
            if(ch1 == 'a' || ch1 == 'e' || ch1 == 'i' || ch1 == 'o' || ch1 == 'u'){
                len++;
            }
            if(ch0 == 'a' || ch0 == 'e' || ch0 == 'i' || ch0 == 'o' || ch0 == 'u'){
                len--;
            } 
            res = Math.max(res,len);
            end_window++;
            start_window++;
        }
        return res;
    }
}

40) Max Consecutive Ones III	(Topic : Sliding Window)
	Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.

	Example 1:

	Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
	Output: 6
	Explanation: [1,1,1,0,0,1,1,1,1,1,1]
	Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
	
	Code :  Time => O(n), Space => O(1)
	class Solution {
    public int longestOnes(int[] nums, int k) {
        int i=0,result = 0,zeroCount=0;
        for(int j=0;j<nums.length;j++){
            if(nums[j] == 0) zeroCount++;

            while(zeroCount > k){
                if(nums[i] == 0) zeroCount--;
                i++;
            }

            result = Math.max(result,j-i+1);
        }
        return result;
    }
}

41) Longest Subarray of 1's After Deleting One Element  (Topic : Sliding Window)
	Given a binary array nums, you should delete one element from it.

	Return the size of the longest non-empty subarray containing only 1's in the resulting array. Return 0 if there is no such subarray.

	Example 1:

	Input: nums = [1,1,0,1]
	Output: 3
	Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.
	
	Code :   Time => O(n), Space => O(1)
	class Solution {
    public int longestSubarray(int[] nums) {
        int i=0,zeroCount = 0,result = 0;
        for(int j=0;j<nums.length;j++){
            if(nums[j] == 0){
                zeroCount++;
            }
            while(zeroCount > 1){
                if(nums[i] == 0) zeroCount--;
                i++;
            }
            result = Math.max(result,j-i);
        }
        return result;
    }
}

42)  Majority Element  (Sorting)
	Given an array nums of size n, return the majority element.

	The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.

	Example 1:

	Input: nums = [3,2,3]
	Output: 3
	
	Code :
	class Solution {
    public int majorityElement(int[] nums) {
        int count = 1, ele = nums[0], res = nums[0];
        for(int i=1;i<nums.length;i++){
            if(nums[i] == ele) count++;
            else count--;
            if(count == 0){
                ele = nums[i];
                count = 1;
            }
        }

        count = 0;
        for(int i=0;i<nums.length;i++){
            if(ele == nums[i]) count++;
        }

        if(count > nums.length/2) return ele;
        return -1;
    }
}

43) 







