1) Contains Duplicate number in array
	Code :
	class Solution {
    public boolean containsDuplicate(int[] nums) {
        HashSet<Integer> set = new HashSet<>();
        for(int i : nums){
            if(set.contains(i)) return true;
            set.add(i);
        }
        return false;
    }
}

2) Missing Number : Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.
	Input: nums = [3,0,1]
	Output: 2
	Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.
	
	Code :
	class Solution {
    public int missingNumber(int[] nums) {
        int x1 = nums[0]; //to calculate xor of all array numbers
        int x2 = 1; //to caluculate xor of 1 to n

        for(int i=1;i<nums.length;i++){
            x1 ^= nums[i];
        }

        for(int i=2;i<=nums.length;i++){
            x2 ^= i;
        }

        return x1^x2;
    }
}

3) Find All Numbers Disappeared in an Array : Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.
	Input: nums = [4,3,2,7,8,2,3,1]
	Output: [5,6]
	
	Code :
	class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        List<Integer> l = new ArrayList<>();
        int n = nums.length;
        for(int i=0;i<n;i++){
            int index = Math.abs(nums[i]) - 1;
            if(nums[index] > 0) nums[index] *= -1;
        }
        for(int i=0;i<n;i++){
            if(nums[i] > 0) l.add(i+1);
        }
        return l;
    }
}

4) Single Number : Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.

	You must implement a solution with a linear runtime complexity and use only constant extra space.
	Input: nums = [2,2,1]
	Output: 1
	
	Code :
	class Solution {
    public int singleNumber(int[] nums) {
        int result = nums[0];
        for(int i=1;i<nums.length;i++){
            result ^= nums[i];
        }
        return result;
    }
}

5) Linked List Cycle : (Topic Tags : Fast and slow pointer)
	Example 1:
	
	<img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png">
	
	Input: head = [3,2,0,-4], pos = 1
	Output: true
	Explanation: There is a cycle in the linked list, where the tail 
	
	Code :
	public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head==null || head.next == null){
            return false;
        }
        ListNode slow = head,fast=head.next;
        while(fast != null && fast.next != null){
            if(slow == fast) return true;
            fast = fast.next.next;
            slow = slow.next;
        }
        return false;
    }
}
	
6) Middle of the Linked List : (Topic Tags : Fast and slow pointer)
	Given the head of a singly linked list, return the middle node of the linked list.

	If there are two middle nodes, return the second middle node.

	Example 1:
	<img src = "https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg">

	Input: head = [1,2,3,4,5]
	Output: [3,4,5]
	Explanation: The middle node of the list is node 3.
	
	Code :
	class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode front = head.next;
        ListNode back = head;
        while(front!=null && front.next!=null){
            front = front.next.next;
            back = back.next;
        }
        if(front == null) return back;
        return back.next;
    }
}

7) Reverse Linked List (Topic : Inplace reversal of linked list)
	Given the head of a singly linked list, reverse the list, and return the reversed list.

 

	Example 1:


	Input: head = [1,2,3,4,5]
	Output: [5,4,3,2,1
	
	Code :
	class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode curr = head;
        ListNode prev = null;
        ListNode temp = head;
        while(curr != null){
            temp = temp.next;
            curr.next = prev;
            prev = curr;
            curr = temp;
        }
        return prev;
    }
}

8) Palindrome Linked List : (Topic Tags : Fast and slow pointer)
	Given the head of a singly linked list, return true if it is a 
	palindrome
	 or false otherwise.

	 

	Example 1:


	Input: head = [1,2,2,1]
	Output: true
	
	Code :
	class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null || head.next == null){
            return true;
        }
        if(head.next.next == null){
            return head.val == head.next.val;
        }
        long rev_num = 0;
        
        while(head != null){
            rev_num = (rev_num*10) + head.val;
            head = head.next;
        }
        
        long num = 0;
        long x = rev_num;
        while(x != 0){
            num = (num*10) + (x%10);
            x /= 10;
        }
        return num == rev_num;
	}
}
	
9)  Remove Linked List Elements : (Topic Tags : Fast and slow pointer)
	Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.
	Example 1:


	Input: head = [1,2,6,3,4,5,6], val = 6
	Output: [1,2,3,4,5]
	
	Code :
	class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode curr = dummy;
        while(curr.next != null){
            if(curr.next.val == val){
                curr.next = curr.next.next;
            }else
            curr = curr.next;
        }
        
        return dummy.next;
    }
}

10) Remove Duplicates from Sorted List	(Topic Tags : Fast and slow pointer)
	Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.

	Example 1:


	Input: head = [1,1,2]
	Output: [1,2]
	
	Code : 
	class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head==null || head.next==null){
            return head;
        }
        ListNode temp = head.next;
        ListNode ptr = head;
        while(temp!=null){
            if(temp.val != ptr.val){
                ptr.next = temp;
                ptr = ptr.next;
            }
            temp = temp.next;
        }
        ptr.next = null;
        return head;
    }
}

11) Merge Two Sorted Lists (Topic Tags : Two pointer)
	You are given the heads of two sorted linked lists list1 and list2.

	Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.

	Return the head of the merged linked list.

	 

	Example 1:


	Input: list1 = [1,2,4], list2 = [1,3,4]
	Output: [1,1,2,3,4,4]
	
	Code :
	class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode newhead = null;
    ListNode ptr1 = list1; 
    ListNode ptr2 = list2; 
    ListNode ptr3 = null;

    while (ptr1 != null && ptr2 != null) {
        if (ptr1.val <= ptr2.val) {
            if (newhead == null) {
                newhead = ptr1;
                ptr3 = newhead;
            } else {
                ptr3.next = ptr1;
                ptr3 = ptr3.next;
            }
            ptr1 = ptr1.next;
        } else {
            if (newhead == null) {
                newhead = ptr2;
                ptr3 = newhead;
            } else {
                ptr3.next = ptr2;
                ptr3 = ptr3.next;
            }
            ptr2 = ptr2.next;
        }
    }
    
    if (ptr1 != null) 
        ptr3.next = ptr1;
    if (ptr2 != null)
        ptr3.next = ptr2;

    return newhead;
    }
}

12) Binary Search (Topic : Binary Search)
	Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.

	You must write an algorithm with O(log n) runtime complexity.

	 

	Example 1:

	Input: nums = [-1,0,3,5,9,12], target = 9
	Output: 4
	Explanation: 9 exists in nums and its index is 4
	
	Code :
	class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length-1;
        while(left <= right){
            int mid = (left + right)/2;
            if(nums[mid] == target) return mid;
            if(nums[mid] < target) left = mid+1;
            else right = mid-1;
        }
        return -1;
    }
}

13) Find Smallest Letter Greater Than Target (Topic : Binary Search)
	You are given an array of characters letters that is sorted in non-decreasing order, and a character target. There are at least two different characters in letters.
	Return the smallest character in letters that is lexicographically greater than target. If such a character does not exist, return the first character in letters.
	Example 1:

	Input: letters = ["c","f","j"], target = "a"
	Output: "c"
	Explanation: The smallest character that is lexicographically greater than 'a' in letters is 'c'.
	
	Code :
	class Solution {
    public char nextGreatestLetter(char[] arr, char target) {
        int left = 0, right = arr.length-1;
        if(arr[0] > target || arr[right] <= target) return arr[0];
        char res = ' ';
        while(left <= right){
            int mid = (left+right)/2;
            if(arr[mid] > target){
                res = arr[mid];
                right = mid-1;
            }
            if(arr[mid] <= target){
                left = mid+1;
            }else{
                right = mid-1;
            }
        }
        return res;
    }
}

14) Convert 1D Array Into 2D Array (Topic : Array)
	Input: original = [1,2,3,4], m = 2, n = 2
	Output: [[1,2],[3,4]]
	Explanation: The constructed 2D array should contain 2 rows and 2 columns.
	The first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array.
	The second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array.
	
	Code :
	class Solution {
    public int[][] construct2DArray(int[] original, int m, int n) {
        int result[][] = new int[m][n];
        if(m*n != original.length) return new int[0][0];
     
        int k=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                result[i][j] = original[k];
                k++;
            }
        }
        return result;
    }
}

15)  Move Zeroes (Topic : Arrays, Two Pointers)
	Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

	Note that you must do this in-place without making a copy of the array.

	 

	Example 1:

	Input: nums = [0,1,0,3,12]
	Output: [1,3,12,0,0]
	
	Code :
	class Solution {
    public void swap(int arr[],int i, int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    public void moveZeroes(int[] nums) {
        int i=0,j=0;
        while(i<nums.length){
            if(nums[i] != 0){
                swap(nums,i,j);
                j++;
            }
            i++;
        }
    }
}

16) Product of Array Except Self   (Topic : Arrays)
	Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].

	The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.

	You must write an algorithm that runs in O(n) time and without using the division operation.

	 

	Example 1:

	Input: nums = [1,2,3,4]
	Output: [24,12,8,6]
	
	Code :
	class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int pre = 1;
        int post = 1;
        int answer[] = new int[n];

        for(int i=0;i<n;i++){
            answer[i] = pre;
            pre *= nums[i];
        }

        for(int i=n-1;i>=0;i--){
            answer[i] *= post;
            post *= nums[i];
        }

        return answer;
    }
}

17) Find the Duplicate Number (Topic : Array, Binary Search, Two Pointers)
	Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.

	There is only one repeated number in nums, return this repeated number.

	You must solve the problem without modifying the array nums and uses only constant extra space.

	 

	Example 1:

	Input: nums = [1,3,4,2,2]
	Output: 2
	
	Code :
	class Solution {
    public int findDuplicate(int[] nums) {
        int slow = 0, fast = 0;
        do{
            slow = nums[slow];
            fast = nums[nums[fast]];
        }while(slow != fast);

        slow = 0;
        while(slow != fast){
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }    
}

18) Find All Duplicates in an Array (Topic : Arrays)

	Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.

	You must write an algorithm that runs in O(n) time and uses only constant extra space.

	Example 1:

	Input: nums = [4,3,2,7,8,2,3,1]
	Output: [2,3]
	
	Code :
	class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> l = new ArrayList<>();
        
        for(int i=0;i<nums.length;i++){
            int idx = Math.abs(nums[i]) - 1;
            if(nums[idx] < 0) l.add(Math.abs(nums[i]));
            else nums[idx] *= -1;
        }

        return l;
    }
}

19) Set Matrix Zeroes   (Topic : Arrays)
	Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.
	You must do it in place.
	Example 1:

	Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]
	Output: [[1,0,1],[0,0,0],[1,0,1]]
	
	Code :
	class Solution {
    public void setZeroes(int[][] matrix) {
        boolean found_row = false, found_col = false;
        for(int i=0;i<matrix.length;i++){
           
            for(int j=0;j<matrix[i].length;j++){
                if(matrix[i][j] == 0){
                    if(i == 0) found_row = true;
                    if(j == 0) found_col = true;
                    matrix[0][j] = 0;
                    matrix[i][0] = 0;
                }
            }
        }
        
        for(int i=1;i<matrix.length;i++){
            for(int j=1;j<matrix[i].length;j++){
                if(matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;
            }
        }

        if(found_col)
        for(int i=0;i<matrix.length;i++){
            matrix[i][0] = 0;
        }

        if(found_row)
        for(int i=0;i<matrix[0].length;i++){
            matrix[0][i] = 0;
        }
	}
}

20) Spiral Matrix	(Topic : Arrays)
	Given an m x n matrix, return all elements of the matrix in spiral order.
	Example 1:
	Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
	Output: [1,2,3,6,9,8,7,4,5]
	
	Code :
	class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> l = new ArrayList<>();
        int m = matrix.length, n = matrix[0].length;
        int rowBegin = 0, rowEnd = m-1, colBegin = 0, colEnd = n-1;

        while(rowBegin <= rowEnd && colBegin <= colEnd) {
            for(int i=colBegin;i<=colEnd;i++) l.add(matrix[rowBegin][i]);
            rowBegin++;

            for(int i=rowBegin;i<=rowEnd;i++) l.add(matrix[i][colEnd]);
            colEnd--;

            if(rowBegin <= rowEnd)
            for(int i=colEnd;i>=colBegin;i--) l.add(matrix[rowEnd][i]);
            rowEnd--;

            if(colBegin <= colEnd)
            for(int i=rowEnd;i>=rowBegin;i--) l.add(matrix[i][colBegin]);
            colBegin++;
        }
        return l;
    }
}

21)  Peak Index in a Mountain Array (Topic : Binary Search)
	An array arr is a mountain if the following properties hold:

	arr.length >= 3
	There exists some i with 0 < i < arr.length - 1 such that:
	arr[0] < arr[1] < ... < arr[i - 1] < arr[i] 
	arr[i] > arr[i + 1] > ... > arr[arr.length - 1]
	Given a mountain array arr, return the index i such that arr[0] < arr[1] < ... < arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1].

	You must solve it in O(log(arr.length)) time complexity.

	 

	Example 1:

	Input: arr = [0,1,0]
	Output: 1
	
	Code :
	class Solution {
    public int peakIndexInMountainArray(int[] arr) {
        if(arr.length < 3) return 0;
       int left = 1, right = arr.length-2;
       while(left <= right){
           int mid = (left + right)/2;
           if(arr[mid] > arr[mid-1] && arr[mid] > arr[mid+1]) return mid;
           else if(arr[mid] > arr[mid-1]) left = mid+1;
           else right = mid-1;
           else low = mid+1; //if there is depth
       }
       return 0;
    }
}

22) Minimum in Sorted Rotated Array  (Topic Tags : Binary Search)

	Input: nums = [3,4,5,1,2]
	Output: 1
	Explanation: The original array was [1,2,3,4,5] rotated 3 times.
	
	Code :
	class Solution {
    public int findMin(int[] arr) {
        int low = 0, high = arr.length-1;
        int ans = Integer.MAX_VALUE;
        //find min of each sorted part in array
        while( low <= high ){
            int mid = (low + high)/2;

            if(arr[low] <= arr[high]){      //If array is already sorted
                return Math.min(arr[low],ans);
            }
            if(arr[mid] >= arr[low]){     //If left of mid is sorted
                ans = Math.min(ans,arr[low]);
                low = mid+1;
            }else{
                ans = Math.min(ans,arr[mid]);        //If right of mid is sorted
                high = mid-1;
            }
        }
        return ans;
    }
}

23) Find Peak Element   (Topic : Binary Search)
	A peak element is an element that is strictly greater than its neighbors.

	Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.

	You may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.

	You must write an algorithm that runs in O(log n) time.

	Example 1:

	Input: nums = [1,2,3,1]
	Output: 2
	Explanation: 3 is a peak element and your function should return the index number 2.
	
	Code :
	
	class Solution {
    public int findPeakElement(int[] nums) {
        if(nums.length == 1) return 0;
        if(nums[0] > nums[1]){
            return 0;
        }
        if(nums[nums.length-1] > nums[nums.length-2]) return nums.length-1;
        int low = 1, high = nums.length-2;
        while(low <= high){
            int mid = (low+high)/2;
            if(nums[mid] > nums[mid-1] && nums[mid] > nums[mid+1]) return mid;   //If mid is at peak
            else if(nums[mid] > nums[mid-1]) low = mid+1;   //peak is at right of mid as it is increasing
            else high = mid-1;   //peak is at left of mid as it is decreasing
        }
        return -1;
    }
}

24) Search in Rotated Sorted Array   (Topic Tags : Binary Search)
	There is an integer array nums sorted in ascending order (with distinct values).

	Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].

	Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.

	You must write an algorithm with O(log n) runtime complexity.

	 

	Example 1:

	Input: nums = [4,5,6,7,0,1,2], target = 0
	Output: 4
	
	Code :
	class Solution {
    public int search(int[] arr, int target) {
        int low=0, high=arr.length-1;
        while(low <= high){
            int mid = (low+high)/2;
            if(arr[mid] == target) return mid;
            if(arr[low] <= arr[mid]){   //if left part is sorted
                if(target <= arr[mid] && target >= arr[low]){ 
                    high = mid-1;
                }else{
                    low = mid+1;
                }
            }else{
                if(target >= arr[mid] && target <= arr[high]){  //if right part is sorted
                    low = mid+1; 
                }else{
                    high = mid-1;
                }
            }
        }
        return -1;
    }
}

25) Search in Rotated Sorted Array II
	Example 1:

	Input: nums = [2,5,6,0,0,1,2], target = 0
	Output: true
	
	Code :
	class Solution {
    public boolean search(int[] nums, int target) {
        int low = 0, high = nums.length-1;
        while(low <= high){
            int mid = (low + high)/2;
            if(nums[mid] == target) return true;
            if(nums[mid] == nums[low] && nums[mid]==nums[high]){   //Here is ambuguity to find which part is sorted 
                low++;
                high--;
                continue;
            }
            if(nums[mid] >= nums[low]){
                if(target >= nums[low] && target <= nums[mid]){
                    high = mid-1;
                }else{
                    low = mid+1;
                }
            }else{
                if(target >= nums[mid] && target <= nums[high]){
                    low = mid+1;
                }else{
                    high = mid-1;
                }
            }
        }
        return false;
    }
}

26) Search a fully sorted 2D Matrix
	You are given an m x n integer matrix matrix with the following two properties:

	Each row is sorted in non-decreasing order.
	The first integer of each row is greater than the last integer of the previous row.
	Given an integer target, return true if target is in matrix or false otherwise.

	You must write a solution in O(log(m * n)) time complexity.

	 

	Example 1:


	Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
	Output: true
	
	Code :
	class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        //Solving by visualizing a 2D matrix in a single array 
        //index in single array = matrix[index/m][index%m] i.e. row = index/m, col = index%m
        int m = matrix.length, n = matrix[0].length;
        int low = 0, high = m*n-1;
        while(low <= high){
            int mid = (low+high)/2;
            int row = mid/n, col = mid%n;
            if(matrix[row][col] == target) return true;
            if(matrix[row][col] > target) high = mid-1;
            else low = mid+1;
        }
        return false;
    }
}

27) Search a 2D Matrix II
	Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:

	Integers in each row are sorted in ascending from left to right.
	Integers in each column are sorted in ascending from top to bottom.
	 

	Example 1:


	Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
	Output: true
	
	Code :
	class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
	//Eliminating rows and columns, not directly binary search
	//starting top right corner or bottom left corner of matrix as these two points only have one side increasing and other decreasing. 
	//Using this we can decide whether we have to eleminate row or column
	//Time => O(log(m*n))
        int row = 0, col = matrix[0].length-1;
        while(row < matrix.length && col >= 0){
            if(matrix[row][col] == target) return true;
            if(matrix[row][col] > target) col--;
            else row++;
        }
        return false;
    }
}



