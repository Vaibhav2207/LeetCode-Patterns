1) Contains Duplicate number in array
	Code :
	class Solution {
    public boolean containsDuplicate(int[] nums) {
        HashSet<Integer> set = new HashSet<>();
        for(int i : nums){
            if(set.contains(i)) return true;
            set.add(i);
        }
        return false;
    }
}

2) Missing Number : Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.
	Input: nums = [3,0,1]
	Output: 2
	Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.
	
	Code :
	class Solution {
    public int missingNumber(int[] nums) {
        int x1 = nums[0]; //to calculate xor of all array numbers
        int x2 = 1; //to caluculate xor of 1 to n

        for(int i=1;i<nums.length;i++){
            x1 ^= nums[i];
        }

        for(int i=2;i<=nums.length;i++){
            x2 ^= i;
        }

        return x1^x2;
    }
}

3) Find All Numbers Disappeared in an Array : Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.
	Input: nums = [4,3,2,7,8,2,3,1]
	Output: [5,6]
	
	Code :
	class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        List<Integer> l = new ArrayList<>();
        int n = nums.length;
        for(int i=0;i<n;i++){
            int index = Math.abs(nums[i]) - 1;
            if(nums[index] > 0) nums[index] *= -1;
        }
        for(int i=0;i<n;i++){
            if(nums[i] > 0) l.add(i+1);
        }
        return l;
    }
}

4) Single Number : Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.

	You must implement a solution with a linear runtime complexity and use only constant extra space.
	Input: nums = [2,2,1]
	Output: 1
	
	Code :
	class Solution {
    public int singleNumber(int[] nums) {
        int result = nums[0];
        for(int i=1;i<nums.length;i++){
            result ^= nums[i];
        }
        return result;
    }
}

5) Linked List Cycle : (Topic Tags : Fast and slow pointer)
	Example 1:
	
	<img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png">
	
	Input: head = [3,2,0,-4], pos = 1
	Output: true
	Explanation: There is a cycle in the linked list, where the tail 
	
	Code :
	public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head==null || head.next == null){
            return false;
        }
        ListNode slow = head,fast=head.next;
        while(fast != null && fast.next != null){
            if(slow == fast) return true;
            fast = fast.next.next;
            slow = slow.next;
        }
        return false;
    }
}
	
6) Middle of the Linked List : (Topic Tags : Fast and slow pointer)
	Given the head of a singly linked list, return the middle node of the linked list.

	If there are two middle nodes, return the second middle node.

	Example 1:
	<img src = "https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg">

	Input: head = [1,2,3,4,5]
	Output: [3,4,5]
	Explanation: The middle node of the list is node 3.
	
	Code :
	class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode front = head.next;
        ListNode back = head;
        while(front!=null && front.next!=null){
            front = front.next.next;
            back = back.next;
        }
        if(front == null) return back;
        return back.next;
    }
}

7) Reverse Linked List (Topic : Inplace reversal of linked list)
	Given the head of a singly linked list, reverse the list, and return the reversed list.

 

	Example 1:


	Input: head = [1,2,3,4,5]
	Output: [5,4,3,2,1
	
	Code :
	class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode curr = head;
        ListNode prev = null;
        ListNode temp = head;
        while(curr != null){
            temp = temp.next;
            curr.next = prev;
            prev = curr;
            curr = temp;
        }
        return prev;
    }
}

8) Palindrome Linked List : (Topic Tags : Fast and slow pointer)
	Given the head of a singly linked list, return true if it is a 
	palindrome
	 or false otherwise.

	 

	Example 1:


	Input: head = [1,2,2,1]
	Output: true
	
	Code :
	class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null || head.next == null){
            return true;
        }
        if(head.next.next == null){
            return head.val == head.next.val;
        }
        long rev_num = 0;
        
        while(head != null){
            rev_num = (rev_num*10) + head.val;
            head = head.next;
        }
        
        long num = 0;
        long x = rev_num;
        while(x != 0){
            num = (num*10) + (x%10);
            x /= 10;
        }
        return num == rev_num;
	}
}
	
9)  Remove Linked List Elements : (Topic Tags : Fast and slow pointer)
	Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.
	Example 1:


	Input: head = [1,2,6,3,4,5,6], val = 6
	Output: [1,2,3,4,5]
	
	Code :
	class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode curr = dummy;
        while(curr.next != null){
            if(curr.next.val == val){
                curr.next = curr.next.next;
            }else
            curr = curr.next;
        }
        
        return dummy.next;
    }
}

10) Remove Duplicates from Sorted List	(Topic Tags : Fast and slow pointer)
	Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.

	Example 1:


	Input: head = [1,1,2]
	Output: [1,2]
	
	Code : 
	class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head==null || head.next==null){
            return head;
        }
        ListNode temp = head.next;
        ListNode ptr = head;
        while(temp!=null){
            if(temp.val != ptr.val){
                ptr.next = temp;
                ptr = ptr.next;
            }
            temp = temp.next;
        }
        ptr.next = null;
        return head;
    }
}

11) Merge Two Sorted Lists (Topic Tags : Two pointer)
	You are given the heads of two sorted linked lists list1 and list2.

	Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.

	Return the head of the merged linked list.

	 

	Example 1:


	Input: list1 = [1,2,4], list2 = [1,3,4]
	Output: [1,1,2,3,4,4]
	
	Code :
	class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode newhead = null;
    ListNode ptr1 = list1; 
    ListNode ptr2 = list2; 
    ListNode ptr3 = null;

    while (ptr1 != null && ptr2 != null) {
        if (ptr1.val <= ptr2.val) {
            if (newhead == null) {
                newhead = ptr1;
                ptr3 = newhead;
            } else {
                ptr3.next = ptr1;
                ptr3 = ptr3.next;
            }
            ptr1 = ptr1.next;
        } else {
            if (newhead == null) {
                newhead = ptr2;
                ptr3 = newhead;
            } else {
                ptr3.next = ptr2;
                ptr3 = ptr3.next;
            }
            ptr2 = ptr2.next;
        }
    }
    
    if (ptr1 != null) 
        ptr3.next = ptr1;
    if (ptr2 != null)
        ptr3.next = ptr2;

    return newhead;
    }
}

12) Binary Search (Topic : Binary Search)
	Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.

	You must write an algorithm with O(log n) runtime complexity.

	 

	Example 1:

	Input: nums = [-1,0,3,5,9,12], target = 9
	Output: 4
	Explanation: 9 exists in nums and its index is 4
	
	Code :
	class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length-1;
        while(left <= right){
            int mid = (left + right)/2;
            if(nums[mid] == target) return mid;
            if(nums[mid] < target) left = mid+1;
            else right = mid-1;
        }
        return -1;
    }
}

13) Find Smallest Letter Greater Than Target (Topic : Binary Search)
	You are given an array of characters letters that is sorted in non-decreasing order, and a character target. There are at least two different characters in letters.
	Return the smallest character in letters that is lexicographically greater than target. If such a character does not exist, return the first character in letters.
	Example 1:

	Input: letters = ["c","f","j"], target = "a"
	Output: "c"
	Explanation: The smallest character that is lexicographically greater than 'a' in letters is 'c'.
	
	Code :
	class Solution {
    public char nextGreatestLetter(char[] arr, char target) {
        int left = 0, right = arr.length-1;
        if(arr[0] > target || arr[right] <= target) return arr[0];
        char res = ' ';
        while(left <= right){
            int mid = (left+right)/2;
            if(arr[mid] > target){
                res = arr[mid];
                right = mid-1;
            }
            if(arr[mid] <= target){
                left = mid+1;
            }else{
                right = mid-1;
            }
        }
        return res;
    }
}

14) Convert 1D Array Into 2D Array (Topic : Array)
	Input: original = [1,2,3,4], m = 2, n = 2
	Output: [[1,2],[3,4]]
	Explanation: The constructed 2D array should contain 2 rows and 2 columns.
	The first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array.
	The second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array.
	
	Code :
	class Solution {
    public int[][] construct2DArray(int[] original, int m, int n) {
        int result[][] = new int[m][n];
        if(m*n != original.length) return new int[0][0];
     
        int k=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                result[i][j] = original[k];
                k++;
            }
        }
        return result;
    }
}

15)  Move Zeroes (Topic : Arrays, Two Pointers)
	Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

	Note that you must do this in-place without making a copy of the array.

	 

	Example 1:

	Input: nums = [0,1,0,3,12]
	Output: [1,3,12,0,0]
	
	Code :
	class Solution {
    public void swap(int arr[],int i, int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    public void moveZeroes(int[] nums) {
        int i=0,j=0;
        while(i<nums.length){
            if(nums[i] != 0){
                swap(nums,i,j);
                j++;
            }
            i++;
        }
    }
}

16) Product of Array Except Self   (Topic : Arrays)
	Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].

	The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.

	You must write an algorithm that runs in O(n) time and without using the division operation.

	 

	Example 1:

	Input: nums = [1,2,3,4]
	Output: [24,12,8,6]
	
	Code :
	class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int pre = 1;
        int post = 1;
        int answer[] = new int[n];

        for(int i=0;i<n;i++){
            answer[i] = pre;
            pre *= nums[i];
        }

        for(int i=n-1;i>=0;i--){
            answer[i] *= post;
            post *= nums[i];
        }

        return answer;
    }
}

17) Find the Duplicate Number (Topic : Array, Binary Search, Two Pointers)
	Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.

	There is only one repeated number in nums, return this repeated number.

	You must solve the problem without modifying the array nums and uses only constant extra space.

	 

	Example 1:

	Input: nums = [1,3,4,2,2]
	Output: 2
	
	Code :
	class Solution {
    public int findDuplicate(int[] nums) {
        int slow = 0, fast = 0;
        do{
            slow = nums[slow];
            fast = nums[nums[fast]];
        }while(slow != fast);

        slow = 0;
        while(slow != fast){
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }    
}

18) Find All Duplicates in an Array (Topic : Arrays)

	Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.

	You must write an algorithm that runs in O(n) time and uses only constant extra space.

	Example 1:

	Input: nums = [4,3,2,7,8,2,3,1]
	Output: [2,3]
	
	Code :
	class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> l = new ArrayList<>();
        
        for(int i=0;i<nums.length;i++){
            int idx = Math.abs(nums[i]) - 1;
            if(nums[idx] < 0) l.add(Math.abs(nums[i]));
            else nums[idx] *= -1;
        }

        return l;
    }
}

19) Set Matrix Zeroes   (Topic : Arrays)
	Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.
	You must do it in place.
	Example 1:

	Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]
	Output: [[1,0,1],[0,0,0],[1,0,1]]
	
	Code :
	class Solution {
    public void setZeroes(int[][] matrix) {
        boolean found_row = false, found_col = false;
        for(int i=0;i<matrix.length;i++){
           
            for(int j=0;j<matrix[i].length;j++){
                if(matrix[i][j] == 0){
                    if(i == 0) found_row = true;
                    if(j == 0) found_col = true;
                    matrix[0][j] = 0;
                    matrix[i][0] = 0;
                }
            }
        }
        
        for(int i=1;i<matrix.length;i++){
            for(int j=1;j<matrix[i].length;j++){
                if(matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;
            }
        }

        if(found_col)
        for(int i=0;i<matrix.length;i++){
            matrix[i][0] = 0;
        }

        if(found_row)
        for(int i=0;i<matrix[0].length;i++){
            matrix[0][i] = 0;
        }
	}
}

20) Spiral Matrix	(Topic : Arrays)
	Given an m x n matrix, return all elements of the matrix in spiral order.
	Example 1:
	Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
	Output: [1,2,3,6,9,8,7,4,5]
	
	Code :
	class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> l = new ArrayList<>();
        int m = matrix.length, n = matrix[0].length;
        int rowBegin = 0, rowEnd = m-1, colBegin = 0, colEnd = n-1;

        while(rowBegin <= rowEnd && colBegin <= colEnd) {
            for(int i=colBegin;i<=colEnd;i++) l.add(matrix[rowBegin][i]);
            rowBegin++;

            for(int i=rowBegin;i<=rowEnd;i++) l.add(matrix[i][colEnd]);
            colEnd--;

            if(rowBegin <= rowEnd)
            for(int i=colEnd;i>=colBegin;i--) l.add(matrix[rowEnd][i]);
            rowEnd--;

            if(colBegin <= colEnd)
            for(int i=rowEnd;i>=rowBegin;i--) l.add(matrix[i][colBegin]);
            colBegin++;
        }
        return l;
    }
}

21)  Peak Index in a Mountain Array (Topic : Binary Search)
	An array arr is a mountain if the following properties hold:

	arr.length >= 3
	There exists some i with 0 < i < arr.length - 1 such that:
	arr[0] < arr[1] < ... < arr[i - 1] < arr[i] 
	arr[i] > arr[i + 1] > ... > arr[arr.length - 1]
	Given a mountain array arr, return the index i such that arr[0] < arr[1] < ... < arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1].

	You must solve it in O(log(arr.length)) time complexity.

	 

	Example 1:

	Input: arr = [0,1,0]
	Output: 1
	
	Code :
	class Solution {
    public int peakIndexInMountainArray(int[] arr) {
        if(arr.length < 3) return 0;
       int left = 1, right = arr.length-2;
       while(left <= right){
           int mid = (left + right)/2;
           if(arr[mid] > arr[mid-1] && arr[mid] > arr[mid+1]) return mid;
           else if(arr[mid] > arr[mid-1]) left = mid+1;
           else right = mid-1;
           else low = mid+1; //if there is depth
       }
       return 0;
    }
}




